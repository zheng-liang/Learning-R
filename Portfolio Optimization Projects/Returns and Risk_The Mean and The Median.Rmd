---
title: 'Returns and Risk: The Mean and The Median'
author: "Tan Zheng Liang"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: show 
    highlight: tango
    theme: flatly
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.align="center", message = FALSE, warning = FALSE)
knitr::knit_hooks$set(purl = knitr::hook_purl)
```

## 1 Introduction

In this project, my intention is to find out if using median returns in portfolio optimization could lead to better portfolio performance compared to mean returns. The use of mean returns might not accurately describe expected returns due to the non-normal distribution of financial returns. The mean is also known to be affected by outliers, whereas the median tend to be a more robust measure of central tendency. 

(To be completed last)

## 2 Packages Required

```{r load packages}
library(doParallel) # For parallel computation in foreach loops
library(PortfolioAnalytics) # For portfolio optimization and analysis
library(RColorBrewer) # For color palettes in plots
library(tidyquant) # For quantmod and PerformanceAnalytics functions
library(tidyverse) # For dplyr and ggplot2 functions (data manipulation and plotting)
```

## 3 Retrieve Stock Prices and Calculate Returns {.tabset .tabset-pills}

I retrieved the weekly adjusted closing prices of 10 stocks from Yahoo Finance, starting January 2015 to June 2022. The weekly returns are then calculated using the discrete/simple method to be used in calculating portfolio returns.

The 10 stocks used in this project are Procter & Gamble (PG), Walmart (WMT), Booking Holdings (BKNG), Salesforce (CRM), 3M (MMM), Starbucks (SBUX), Walt Disney (DIS), Home Depot (HD), Coca-Cola (KO), and NVIDIA (NVDA).

### 3.1 Retrieve Price Data

The weekly adjusted closing price of the tickers can be retrieved using **`quantmod::getSymbols()`**. 

```{r retrieve price data}
# Vector of tickers to include in portfolio
tickers <- c("PG", "WMT", "BKNG", "CRM", "MMM", "SBUX", "DIS", "HD", "KO", "NVDA")

startdate <- as.Date("2015-01-01")
enddate <- as.Date("2022-07-01")

price_data <- NULL

# Loop to get adjusted closing prices for all stocks
for(t in tickers) {
  price_data <- cbind(price_data,
                      quantmod::getSymbols(Symbols = t, src = "yahoo", auto.assign = FALSE,
                                           from = startdate, to = enddate, periodicity = "weekly") %>% Ad())
}

# Check dimension of object, start and end date of data collected
dim(price_data); start(price_data); end(price_data)

# See first 6 observations in price_data
head(price_data)
```

### 3.2 Stock Returns for Portfolio

Discrete returns can be calculated using **`PerformanceAnalytics::Return.calculate()`**.

```{r calculate discrete returns}
return_data <- na.omit(PerformanceAnalytics::Return.calculate(prices = price_data, method = "discrete")) %>%
  `colnames<-`(paste(tickers, "Return", sep = "."))

dim(return_data); head(return_data)
```

## 4 Measuring Spread of Data {.tabset .tabset-pills}

### 4.1 Mean and Median

The (arithmetic) mean and median are two measures of central tendency that can be used to describe expected returns of a stock.

Since the distribution of stock returns tend to be non-normal, the median may be a more appropriate measure. For example, the density plot of `PG` shows that the returns do not follow a normal distribution. The Q-Q plot on the top-left corner also indicated a non-normal distribution.

```{r plot historical returns of WMT}
chart.Histogram(R = return_data$PG.Return, 
                method = c("add.density", "add.normal", "add.qqplot"), 
                main = "Density Plot of PG Historical Returns")

legend(x = "topright", legend = c("Density Plot", "Normal Distribution"), lwd = 2, col = c("darkblue", "blue"))
```

The mean and median returns of each stock in the portfolio are:

```{r mean and median of each stock}
stock_means <- apply(X = return_data, MARGIN = 2, FUN = mean)

stock_medians <- apply(X = return_data, MARGIN = 2, FUN = median)

data.frame(rbind(Mean = stock_means, Median = stock_medians))
```

Although the mean and median return values are quite small, we can see that there is a noticeable difference for some of the stocks.

### 4.2 Variance (or Standard Deviation)

The variance measures the squared deviation of returns from the mean, but standard deviation (SD) is used since it is in the same units as returns.

The SD of each stock in the portfolio is:

```{r standard deviation of each stock}
stock_sd <- apply(X = return_data, MARGIN = 2, FUN = sd)

data.frame(rbind(SD = stock_sd))
```

If returns were normally distributed, we can use the 68-95-99 rule, where 68%/95%/99% of returns are within 1SD/2SD/3SD of the mean.

### 4.3 Mean Absolute Deviation

The mean absolute deviation (MAD) is the mean of the absolute deviations between returns and a central point. The central point usually refers to the mean, but the median can be used as well. However, since the mean and median returns are similar, we can expect that the MAD using either of these as the central point would be 

$MAD = \frac{1}{N}\sum_{i=1}^N |R_i - m(R)|$, where $R_i$ is the return of a stock, and $m(R)$ is the mean or median return of the stock.

The MAD around the mean and median of each stock in the portfolio are:

```{r MAD around mean and median of each stock}
stock_MAD <- apply(X = return_data, MARGIN = 2, FUN = function(x) {
  mean(abs(x - mean(x)))
})

stock_MADmed <- apply(X = return_data, MARGIN = 2, FUN = function(x) {
  mean(abs(x - median(x)))
})

data.frame(rbind(MAD_mean = stock_MAD, MAD_median = stock_MADmed))
```

We can see that the MAD of each stock is smaller than its SD as SD places more weight on outliers than MAD. The MAD calculated with the mean and median are quite similar. I would stick with using MAD around the mean as a measure of risk.

### 4.4 Median Absolute Deviation

The median absolute deviation (also abbreviated as MAD, but for the purpose of distinguishing the two measures, I used MeAD instead) is the median of the absolute deviations between returns and its median. It is a robust measure of variability.

$MeAD = med |R_i - med(R)|$, where $R_i$ is the return of a stock, and $med(R)$ is the median return of the stock.

The MeAD of each stock in the portfolio is:

```{r MeAD of each stock}
stock_MeAD <- apply(X = return_data, MARGIN = 2, FUN = function(x) {
  median(abs(x - median(x)))
})

data.frame(rbind(MeAD = stock_MeAD))
```

### 4.5 Summary

The different return and risk measures based on mean and median are summarized below:

```{r summary of section 4}
data.frame(rbind(Mean = stock_means, Median = stock_medians, 
                 SD = stock_sd, MAD_mean = stock_MAD, MAD_median = stock_MADmed, MeAD = stock_MeAD))
```

Portfolio optimization using mean returns and variance/SD and MAD as risk measures are common and a simple Google search would return many research papers and articles on it. Using median returns instead of mean returns have also been widely researched. However, the use of MeAD as a risk measure in portfolio optimization does not seem to be documented. The project tested MeAD as part of the research, but it may be a spurious measure of risk as no statistical tests or simulations to find its significance were carried out.

## 5 Random Portfolios {.tabset .tabset-pills}

### 5.1 Generate Random Portfolios

Optimization based on median measures are usually not implemented by packages and functions, so I had to use a set of random hypothetical portfolios in this project.

Before optimizing any objectives, I generated a set of random portfolios which satisfy constraints where the sum of the component weights must be equal to 1 and the weight of each component is between 0% and 100% of the portfolio.

```{r generate set of random portfolios}
portspec <- PortfolioAnalytics::portfolio.spec(assets = tickers)

# Sum of weights constrained to 1, can also specify as type = "full investment"
portspec <- PortfolioAnalytics::add.constraint(portfolio = portspec,
                                               type = "weight_sum",
                                               min_sum = 1, max_sum = 1)

# Weight of each portfolio component can vary between minimum of 0% and maximum of 100%
portspec <- PortfolioAnalytics::add.constraint(portfolio = portspec,
                                               type="box", 
                                               min = 0, max = 1)

portspec

set.seed(43594)

rand_port <- PortfolioAnalytics::random_portfolios(portfolio = portspec, 
                                                   permutations = 20000, 
                                                   rp_method = "simplex", 
                                                   eliminate = TRUE)

dim(rand_port); head(rand_port)
```

16,049 portfolio permutations were found, which will be used for the rest of this project.

### 5.2 Optimization Strategy

I used three different optimization objectives in this project:

1. Maximize return
2. Minimize risk
3. Minimize risk for a given return

To make the different strategies more practical, I attempted to replicate a half-yearly re-optimization strategy using previous one year data. In this case, I would calculate the return and/or risk of the hypothetical portfolios with 2015 return data and implement the optimal weights on 2016H1. Then, I re-optimize the weights using data from 2015H2 to 2016H1 for 2016H2 and so on. The last re-optimization used 2021 data for 2022H1 since I only retrieved data up to 30 June 2022.

```{r optimization and return period}
opt_periods <- c("2015", "2015-07/2016-06", 
                 "2016", "2016-07/2017-06", 
                 "2017", "2017-07/2018-06", 
                 "2018", "2018-07/2019-06", 
                 "2019", "2019-07/2020-06", 
                 "2020", "2020-07/2021-06", 
                 "2021")

ret_periods <- c("2016-01/2016-06", "2016-07/2016-12", 
                 "2017-01/2017-06", "2017-07/2017-12",
                 "2018-01/2018-06", "2018-07/2018-12",
                 "2019-01/2019-06", "2019-07/2019-12",
                 "2020-01/2020-06", "2020-07/2020-12",
                 "2021-01/2021-06", "2021-07/2021-12",
                 "2022-01/2022-06")

data.frame(cbind(Optimization_Period = opt_periods, Return_Period = ret_periods))
```

### 5.3 Daily Portfolio Returns

The weekly returns of hypothetical portfolios can be calculated using `opt_periods` and `randport` and is based on the formula $R_p = \sum_{i=1}^N R_i w_i$. I used geometric chaining to aggregate returns and rebalanced the portfolios quarterly. We can use the performance of random portfolios in each optimization period to select portfolio weights that optimized that period's return and/or risk.

```{r random portfolio returns}
# Use foreach loop in parallel with dopar

# Important to make sure that we do not use all cores for computation. Check with detectCores(logical = F)
mycluster <- makeCluster(6) # Number of cores to use. I have 8, but may not be suitable for everyone.

# Register parallel computing
registerDoParallel(mycluster)

rp_returns <- foreach(i = opt_periods) %:%
  foreach(j = 1:nrow(randport), .combine = "cbind") %dopar% {
    tmp_return <- PerformanceAnalytics::Return.portfolio(R = return_data[i, ], 
                                                         weights = randport[j, ], 
                                                         geometric = TRUE,
                                                         rebalance_on = "quarters")
  }

# End parallel computing
stopCluster(mycluster)

names(rp_returns) <- opt_periods

for (i in 1:length(rp_returns)) {
  colnames(rp_returns[[i]]) <- paste("RP_", 1:nrow(randport), sep = "")
}
```

## 6 Best Return Portfolio {.tabset .tabset-pills}

In this section, I find portfolios that maximize mean and median returns in each optimization period, although these types of objectives may not be practical in portfolio optimization. It assumes that investors create their portfolios based on the best historical returns. However, these strategies can give an idea of the risks taken by an investor, based on the drawdown of the portfolios.

### 6.1 Maximize Mean Return

```{r find weights for best mean return}
# Find mean portfolio return in each optimization period and find weight that maximizes mean return
maxmean_weight <- foreach(i = 1:length(rp_returns), .combine = "rbind") %do% {
  tmp <- PerformanceAnalytics::Mean.arithmetic(rp_returns[[i]])
  
  opt_weight <- randport[which.max(tmp), ]
}

rownames(maxmean_weight) <- paste("Opt_period", 1:nrow(maxmean_weight))

data.frame(maxmean_weight)
```

```{r daily return of best mean portfolio}
# Returns of best mean portfolio in ret_period using weights from opt_period
maxmean_returns <- foreach(i = ret_periods, j = 1:nrow(maxmean_weight), .combine = "rbind") %do% {
  tmp <- PerformanceAnalytics::Return.portfolio(R = stock_returns[i, ], 
                                                weights = maxmean_weight[j, ], 
                                                geometric = TRUE, 
                                                rebalance_on = "quarters")
}
```

### 6.2 Maximize Median Return

While the finding the mean portfolio return was simple, finding the median portfolio return from median stock returns takes a little more work.

```{r find weights for best median return}
# Find median of each stock in portfolio in each optimization period
med_returns <- foreach(i = opt_periods, .combine = "rbind") %do% {
    tmp <- apply(X = stock_returns[i, ], MARGIN = 2, FUN = median)
}

mycluster <- makeCluster(6) 

registerDoParallel(mycluster)

# Find median portfolio return in each optimization period
portmed <- foreach(i = 1:nrow(med_returns)) %:% # outer loop on med_returns rows of data
  foreach(j = 1:nrow(randport), .combine = "cbind") %dopar% { # inner loop on randport rows
    x <- NULL
    
    for (k in 1:ncol(randport)) { # loop on randport columns
      x <- c(x, rep(med_returns[i,k], randport[j,k] * 1000))
    }
    
    y <- median(x)
    
    return(y)
  }

stopCluster(mycluster)

# Find weights that maximizes median of each optimization period
maxmed_weight <- foreach(i = 1:length(portmed), .combine = "rbind") %do% {
  opt_weight <- randport[which.max(portmed[[i]]), ]
}

rownames(maxmed_weight) <- paste("Opt_period", 1:nrow(maxmed_weight))

data.frame(maxmed_weight)
```

```{r daily return of best median portfolio}
# Returns of best median portfolio in ret_period using weights from opt_period
maxmed_returns <- foreach(i = ret_periods, j = 1:nrow(maxmed_weight), .combine = "rbind") %do% {
  tmp <- PerformanceAnalytics::Return.portfolio(R = stock_returns[i, ], 
                                                weights = maxmed_weight[j, ], 
                                                geometric = TRUE, 
                                                rebalance_on = "quarters")
}
```

### 6.3 Comparison of Best Return Portfolios

```{r plot weights of best return portfolios}
chart.StackedBar(w = maxmean_weight, colorset = RColorBrewer::brewer.pal(n = 10, "Spectral"),
                 main = "Optimal Weights of Best Mean Portfolio", xlab = "Optimization Period", ylab = "Weight")

chart.StackedBar(w = maxmed_weight, colorset = RColorBrewer::brewer.pal(n = 10, "Spectral"),
                 main = "Optimal Weights of Best Median Portfolio", xlab = "Optimization Period", ylab = "Weight")
```

```{r plot returns of best return portfolios}
best_return <- cbind(maxmean_returns, maxmed_returns) %>%
  `colnames<-`(c("Best_Mean", "Best_Median"))

chart.CumReturns(R = best_return, geometric = TRUE, legend.loc = "bottomright", main = "Cumulative Return of Best Return Portfolios")

chart.Drawdown(R = best_return, geometric = TRUE, legend.loc = "bottomright", main = "Drawdown of Best Return Portfolios")
```

```{r perf summary of best return portfolios}
table.AnnualizedReturns(R = best_return, scale = 252, Rf = 0.025/252, geometric = TRUE)

table.DownsideRisk(R = best_return, scale = 252, Rf = 0.025/252, MAR = 0.07/252)

table.Stats(R = best_return)
```

## 7 Minimum Risk Portfolio {.tabset .tabset-pills}

On the opposite spectrum, I find portfolios that minimizes risk in each optimization period in this section.

### 7.1 Minimize Variance

With the simple daily returns of portfolio in `rp_returns`, I can calculate the portfolio variance or standard deviation.











## References 

https://en.wikipedia.org/wiki/Weighted_median

https://en.wikipedia.org/wiki/Median_absolute_deviation

https://en.wikipedia.org/wiki/Average_absolute_deviation

https://statisticsbyjim.com/basics/mean-absolute-deviation/

