---
title: 'Returns and Risks: The Mean and The Median'
author: "Tan Zheng Liang"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: show 
    highlight: tango
    theme: flatly
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.align="center", message = FALSE, warning = FALSE)
knitr::knit_hooks$set(purl = knitr::hook_purl)
```

## 1 Introduction

In this project, my intention is to find out if using median returns in portfolio optimization could lead to better portfolio performance compared to mean returns. The use of mean returns might not accurately describe expected returns due to the non-normal distribution of financial returns. The mean is also known to be affected by outliers, whereas the median tend to be a more robust measure of central tendency. 

The results of this project found that using the median return to find the optimal portfolio did not lead to significant improvement in portfolio performance than using the mean return. However, this should not be taken as evidence against the median return as the project was flawed in its own ways. Firstly, the portfolios optimized only used a selected number of stocks, which means that the results are not generalizable to any portfolio. Secondly, the number of random portfolios used to simulate the performance of hypothetical portfolios was only a small a small subset of an large possible set of permutations, decreasing the likelihood of finding the true optimal portfolio.

## 2 Packages Required

```{r load packages}
library(doParallel) # For parallel computation in foreach loops
library(PortfolioAnalytics) # For portfolio optimization and analysis
library(RColorBrewer) # For color palettes in plots
library(tidyquant) # For quantmod and PerformanceAnalytics functions
library(tidyverse) # For dplyr and ggplot2 functions (data manipulation and plotting)
```

## 3 Retrieve Stock Prices and Calculate Returns {.tabset .tabset-pills}

I retrieved the weekly adjusted closing prices of 10 stocks from Yahoo Finance, starting January 2015 to June 2022. The weekly returns are then calculated using the discrete/simple method to be used in calculating portfolio returns.

The 10 stocks used in this project are Procter & Gamble (PG), Walmart (WMT), Booking Holdings (BKNG), Salesforce (CRM), 3M (MMM), Starbucks (SBUX), Walt Disney (DIS), Home Depot (HD), Coca-Cola (KO), and NVIDIA (NVDA).

### 3.1 Retrieve Price Data

The weekly adjusted closing price of the tickers can be retrieved using **`quantmod::getSymbols()`**. 

```{r retrieve price data}
# Vector of tickers to include in portfolio
tickers <- c("PG", "WMT", "BKNG", "CRM", "MMM", "SBUX", "DIS", "HD", "KO", "NVDA")

startdate <- as.Date("2015-01-01")
enddate <- as.Date("2022-07-01")

price_data <- NULL

# Loop to get adjusted closing prices for all stocks
for(t in tickers) {
  price_data <- cbind(price_data,
                      quantmod::getSymbols(Symbols = t, src = "yahoo", auto.assign = FALSE,
                                           from = startdate, to = enddate, periodicity = "weekly") %>% Ad())
}

# Check dimension of object, start and end date of data collected
dim(price_data); start(price_data); end(price_data)

# See first 6 observations in price_data
head(price_data)
```

### 3.2 Stock Returns for Portfolio

Discrete returns can be calculated using **`PerformanceAnalytics::Return.calculate()`**.

```{r calculate discrete returns}
return_data <- na.omit(PerformanceAnalytics::Return.calculate(prices = price_data, method = "discrete")) %>%
  `colnames<-`(paste(tickers, "Return", sep = "."))

dim(return_data); head(return_data)
```

## 4 Measuring Spread of Data {.tabset .tabset-pills}

### 4.1 Mean and Median

The (arithmetic) mean and median are two measures of central tendency that can be used to describe expected returns of a stock.

Since the distribution of stock returns tend to be non-normal, the median may be a more appropriate measure. For example, the density plot of `PG` shows that the returns do not follow a normal distribution. The Q-Q plot on the top-left corner also indicated a non-normal distribution.

```{r plot historical returns of WMT}
chart.Histogram(R = return_data$PG.Return, 
                method = c("add.density", "add.normal", "add.qqplot"), 
                main = "Density Plot of PG Historical Returns")

legend(x = "topright", legend = c("Density Plot", "Normal Distribution"), lwd = 2, col = c("darkblue", "blue"))
```

The mean and median returns of each stock in the portfolio are:

```{r mean and median of each stock}
stock_means <- apply(X = return_data, MARGIN = 2, FUN = mean)

stock_medians <- apply(X = return_data, MARGIN = 2, FUN = median)

data.frame(rbind(Mean = stock_means, Median = stock_medians))
```

Although the mean and median return values are quite small, we can see a noticeable difference for some of the stocks.

### 4.2 Variance (or Standard Deviation)

The variance measures the squared deviation of returns from the mean, but standard deviation (SD) is used since it is in the same units as returns.

The SD of each stock in the portfolio is:

```{r standard deviation of each stock}
stock_sd <- apply(X = return_data, MARGIN = 2, FUN = sd)

data.frame(rbind(SD = stock_sd))
```

If returns were normally distributed, we can use the 68-95-99 rule, where 68%/95%/99% of returns are within 1SD/2SD/3SD of the mean.

### 4.3 Mean Absolute Deviation

The mean absolute deviation (MAD) is the mean of the absolute deviations between returns and a central point. The central point usually refers to the mean, but the median can be used as well. However, since the mean and median returns are similar, we can expect that the MAD using either of these as the central point would be 

$MAD = \frac{1}{N}\sum_{i=1}^N |R_i - m(R)|$, where $R_i$ is the return of a stock, and $m(R)$ is the mean or median return of the stock.

The MAD around the mean and median of each stock in the portfolio are:

```{r MAD around mean and median of each stock}
stock_MAD <- apply(X = return_data, MARGIN = 2, FUN = function(x) {
  mean(abs(x - mean(x)))
})

stock_MADmed <- apply(X = return_data, MARGIN = 2, FUN = function(x) {
  mean(abs(x - median(x)))
})

data.frame(rbind(MAD_mean = stock_MAD, MAD_median = stock_MADmed))
```

We can see that the MAD of each stock is smaller than its SD as SD places more weight on outliers than MAD. The MAD calculated with the mean and median are quite similar. I would stick with using MAD around the mean as a measure of risk.

### 4.4 Median Absolute Deviation

The median absolute deviation (also abbreviated as MAD, but for the purpose of distinguishing the two measures, I used MeAD instead) is the median of the absolute deviations between returns and its median. It is a robust measure of variability.

$MeAD = med |R_i - med(R)|$, where $R_i$ is the return of a stock, and $med(R)$ is the median return of the stock.

The MeAD of each stock in the portfolio is:

```{r MeAD of each stock}
stock_MeAD <- apply(X = return_data, MARGIN = 2, FUN = function(x) {
  median(abs(x - median(x)))
})

data.frame(rbind(MeAD = stock_MeAD))
```

### 4.5 Summary

The different return and risk measures based on mean and median are summarized below:

```{r summary of section 4}
data.frame(rbind(Mean = stock_means, Median = stock_medians, 
                 SD = stock_sd, MAD_mean = stock_MAD, MAD_median = stock_MADmed, MeAD = stock_MeAD))
```

Portfolio optimization using mean returns and variance/SD and MAD as risk measures are common and a simple Google search would return many research papers and articles on it. Using median returns instead of mean returns have also been widely researched. However, the use of MeAD as a risk measure in portfolio optimization does not seem to be documented. The project tested MeAD as part of the research, but it may be a spurious measure of risk as no statistical tests or simulations to find its significance were carried out.

## 5 Random Portfolios {.tabset .tabset-pills}

### 5.1 Generate Random Portfolios

Optimization based on median measures are usually not implemented by packages and functions, so I had to use a set of random hypothetical portfolios in this project.

Before optimizing any objectives, I generated a set of random portfolios which satisfy constraints where the sum of the component weights must be equal to 1 and the weight of each component is between 0% and 25% of the portfolio.

```{r generate set of random portfolios}
portspec <- PortfolioAnalytics::portfolio.spec(assets = tickers)

# Sum of weights constrained to 1, can also specify as type = "full investment"
portspec <- PortfolioAnalytics::add.constraint(portfolio = portspec,
                                               type = "weight_sum",
                                               min_sum = 1, max_sum = 1)

# Weight of each portfolio component can vary between minimum of 0% and maximum of 25%
portspec <- PortfolioAnalytics::add.constraint(portfolio = portspec,
                                               type="box", 
                                               min = 0, max = 0.25)

portspec

set.seed(43594)

rand_port <- PortfolioAnalytics::random_portfolios(portfolio = portspec, 
                                                   permutations = 20000, 
                                                   rp_method = "sample", 
                                                   eliminate = TRUE)

dim(rand_port); head(rand_port)
```

1,740 portfolio permutations were found, which will be used for the rest of this project.

### 5.2 Optimization Strategy

I used three different optimization objectives in this project:

1. Maximize return
2. Minimize risk
3. Minimize risk for a given return

To make the different strategies more practical, I attempted to replicate a half-yearly re-optimization strategy using previous one year data. In this case, I would calculate the return and/or risk of the hypothetical portfolios with 2015 return data and implement the optimal weights on 2016H1. Then, I re-optimize the weights using data from 2015H2 to 2016H1 for 2016H2 and so on. The last re-optimization used 2021 data for 2022H1 since I only retrieved data up to 30 June 2022.

```{r optimization and return period}
opt_periods <- c("2015", "2015-07/2016-06", 
                 "2016", "2016-07/2017-06", 
                 "2017", "2017-07/2018-06", 
                 "2018", "2018-07/2019-06", 
                 "2019", "2019-07/2020-06", 
                 "2020", "2020-07/2021-06", 
                 "2021")

ret_periods <- c("2016-01/2016-06", "2016-07/2016-12", 
                 "2017-01/2017-06", "2017-07/2017-12",
                 "2018-01/2018-06", "2018-07/2018-12",
                 "2019-01/2019-06", "2019-07/2019-12",
                 "2020-01/2020-06", "2020-07/2020-12",
                 "2021-01/2021-06", "2021-07/2021-12",
                 "2022-01/2022-06")

data.frame(cbind(Optimization_Period = opt_periods, Return_Period = ret_periods))
```

### 5.3 Weekly Portfolio Returns

The weekly returns of hypothetical portfolios can be calculated using `opt_periods` and `randport` and is based on the formula $R_p = \sum_{i=1}^N R_i w_i$. I used geometric chaining to aggregate returns and rebalanced the portfolios quarterly. We can use the performance of random portfolios in each optimization period to select portfolio weights which optimized that period's return and/or risk.

```{r random portfolio returns}
rp_returns <- foreach(i = 1:nrow(rand_port), .combine = "cbind") %do% {
  tmp <- PerformanceAnalytics::Return.portfolio(R = return_data,
                                                weights = rand_port[i, ],
                                                geometric = TRUE,
                                                rebalance_on = "quarters")
}
```

I also calculate the returns of an equal-weight portfolio to compare the performance of optimized portfolios.

```{r return of equal weight portfolio}
# If do not include weights, equal weight portfolio is assumed
ewp_return <- PerformanceAnalytics::Return.portfolio(R = return_data,
                                                     geometric = TRUE,
                                                     rebalance_on = "quarters")
```

## 6 Best Return Portfolio {.tabset .tabset-pills}

In this section, I find portfolios that maximize mean and median returns in each optimization period, although these types of objectives may not be practical in portfolio optimization. It assumes that investors create their portfolios based on the best historical returns. However, these strategies can give an idea of the risks taken by an investor, based on the drawdown of the portfolios.

### 6.1 Maximize Mean Return

Find weights that maximizes mean portfolio returns in each optimization period:

```{r find weights for best mean return}
maxmean_weight <- foreach(i = opt_periods, .combine = "rbind") %do% {
  tmp <- PerformanceAnalytics::Mean.arithmetic(x = rp_returns[i, ])
  
  opt_weight <- rand_port[which.max(tmp), ]
}

rownames(maxmean_weight) <- paste("OP", 1:nrow(maxmean_weight), sep = "")

data.frame(maxmean_weight)
```

Calculate return based on the selected portfolio weights in the return period:

```{r weekly return of best mean portfolio}
# Returns of best mean portfolio in ret_period using weights from opt_period
maxmean_returns <- foreach(i = ret_periods, j = 1:nrow(maxmean_weight), .combine = "rbind") %do% {
  tmp <- PerformanceAnalytics::Return.portfolio(R = return_data[i, ], 
                                                weights = maxmean_weight[j, ], 
                                                geometric = TRUE, 
                                                rebalance_on = "quarters")
}
```

### 6.2 Maximize Median Return

Find weights that maximizes median portfolio returns in each optimization period:

```{r find weights for best median return}
# Find weights that maximizes median of each optimization period
maxmed_weight <- foreach(i = opt_periods, .combine = "rbind") %do% {
  tmp <- apply(X = rp_returns[i, ], MARGIN = 2, FUN = median)
  
  opt_weight <- rand_port[which.max(tmp), ]
}

rownames(maxmed_weight) <- paste("OP", 1:nrow(maxmed_weight), sep = "")

data.frame(maxmed_weight)
```

Calculate return based on the selected portfolio weights in the return period:

```{r weekly return of best median portfolio}
# Returns of best median portfolio in ret_period using weights from opt_period
maxmed_returns <- foreach(i = ret_periods, j = 1:nrow(maxmed_weight), .combine = "rbind") %do% {
  tmp <- PerformanceAnalytics::Return.portfolio(R = return_data[i, ], 
                                                weights = maxmed_weight[j, ], 
                                                geometric = TRUE, 
                                                rebalance_on = "quarters")
}
```

### 6.3 Comparison of Best Return Portfolios

Plot weights of best mean and best median portfolios:

```{r plot weights of best return portfolios}
chart.StackedBar(w = maxmean_weight, colorset = RColorBrewer::brewer.pal(n = 10, "Spectral"),
                 main = "Optimal Weights of Best Mean Portfolio", ylab = "Weight")

chart.StackedBar(w = maxmed_weight, colorset = RColorBrewer::brewer.pal(n = 10, "Spectral"),
                 main = "Optimal Weights of Best Median Portfolio", ylab = "Weight")
```

Plot cumulative return of best mean and best median portfolios against equal-weight portfolio return:

```{r plot returns of best return portfolios}
best_return <- cbind(maxmean_returns, maxmed_returns, ewp_return["2016/",]) %>%
  `colnames<-`(c("Best_Mean", "Best_Median", "Equal Weight"))

chart.CumReturns(R = best_return, geometric = TRUE,
                 legend.loc = "topleft",
                 main = "Cumulative Return of Best Return Portfolios")

chart.Drawdown(R = best_return, geometric = TRUE,
               legend.loc = "bottomleft",
               main = "Drawdown of Best Return Portfolios")
```

Tables of annualized returns, risk measures and statistics:

```{r perf summary of best return portfolios}
table.AnnualizedReturns(R = best_return, scale = 52, Rf = 0.025/52, geometric = TRUE)

table.DownsideRisk(R = best_return, scale = 52, Rf = 0.025/52, MAR = 0.07/52)

table.Stats(R = best_return)
```

### 6.4 Summary

By choosing weights that maximize the median portfolio returns in each optimization period instead of mean portfolio returns, a higher annualized return was achieved, but it came with higher annualized standard deviation. The mean returns over the period was also higher for the Best Median portfolio, with a higher historical expected shortfall and maximum drawdown.

## 7 Minimum Risk Portfolio {.tabset .tabset-pills}

On the opposite spectrum, I find portfolios that minimizes risk in each optimization period in this section.

### 7.1 Minimize Variance

Find weights that minimizes variance/standard deviation in each optimization period:

```{r find weights for minimum variance}
minstd_weight <- foreach(i = opt_periods, .combine = "rbind") %do% {
  tmp <- PerformanceAnalytics::StdDev(R = rp_returns[i, ])
  
  opt_weight <- rand_port[which.min(tmp), ]
}

rownames(minstd_weight) <- paste("OP", 1:nrow(minstd_weight), sep = "")

data.frame(minstd_weight)
```

Calculate return based on the selected portfolio weights in the return period:

```{r weekly return of minimum variance portfolio}
minstd_returns <- foreach(i = ret_periods, j = 1:nrow(minstd_weight), .combine = "rbind") %do% {
  tmp <- PerformanceAnalytics::Return.portfolio(R = return_data[i, ], 
                                                weights = minstd_weight[j, ], 
                                                geometric = TRUE, 
                                                rebalance_on = "quarters")
}
```

### 7.2 Minimize MAD

Find weights that minimizes MAD in each optimization period:

```{r find weights for minimum mean absolute deviation}
minmad_weight <- foreach(i = opt_periods, .combine = "rbind") %do% {
  tmp <- apply(X = rp_returns[i, ], MARGIN = 2, FUN = function(x) {
    mean(abs(x - mean(x)))
    })
  
  opt_weight <- rand_port[which.min(tmp), ]
}

rownames(minmad_weight) <- paste("OP", 1:nrow(minmad_weight), sep = "")

data.frame(minmad_weight)
```

Calculate return based on the selected portfolio weights in the return period:

```{r weekly return of minimum mad portfolio}
minmad_returns <- foreach(i = ret_periods, j = 1:nrow(minmad_weight), .combine = "rbind") %do% {
  tmp <- PerformanceAnalytics::Return.portfolio(R = return_data[i, ], 
                                                weights = minmad_weight[j, ], 
                                                geometric = TRUE, 
                                                rebalance_on = "quarters")
}
```

### 7.3 Minimize MeAD

Find weights that minimizes MeAD in each optimization period:

```{r find weights for minimum median absolute deviation}
minmead_weight <- foreach(i = opt_periods, .combine = "rbind") %do% {
  tmp <- apply(X = rp_returns[i, ], MARGIN = 2, FUN = function(x) {
    median(abs(x - median(x)))
    })
  
  opt_weight <- rand_port[which.min(tmp), ]
}

rownames(minmead_weight) <- paste("OP", 1:nrow(minmead_weight), sep = "")

data.frame(minmead_weight)
```

Calculate return based on the selected portfolio weights in the return period:

```{r weekly return of minimum mead portfolio}
minmead_returns <- foreach(i = ret_periods, j = 1:nrow(minmead_weight), .combine = "rbind") %do% {
  tmp <- PerformanceAnalytics::Return.portfolio(R = return_data[i, ], 
                                                weights = minmead_weight[j, ], 
                                                geometric = TRUE, 
                                                rebalance_on = "quarters")
}
```

### 7.4 Comparison of Minimum Risk Portfolios

Plot weights of minimum risk portfolios:

```{r plot weights of minimum risk portfolios}
chart.StackedBar(w = minstd_weight, colorset = RColorBrewer::brewer.pal(n = 10, "Spectral"),
                 main = "Optimal Weights of Minimum Variance Portfolio", ylab = "Weight")

chart.StackedBar(w = minmad_weight, colorset = RColorBrewer::brewer.pal(n = 10, "Spectral"),
                 main = "Optimal Weights of Minimum MAD Portfolio", ylab = "Weight")

chart.StackedBar(w = minmead_weight, colorset = RColorBrewer::brewer.pal(n = 10, "Spectral"),
                 main = "Optimal Weights of Minimum MeAD Portfolio", ylab = "Weight")
```

Plot cumulative return of minimum risk portfolios against equal-weight portfolio return:

```{r plot returns of minimum risk portfolios}
min_risk <- cbind(minstd_returns, minmad_returns, minmead_returns, ewp_return["2016/",]) %>%
  `colnames<-`(c("Min_Var", "Min_MAD", "Min_MeAD", "Equal Weight"))

chart.CumReturns(R = min_risk, geometric = TRUE,
                 legend.loc = "topleft",
                 main = "Cumulative Return of Minimum Risk Portfolios")

chart.Drawdown(R = min_risk, geometric = TRUE,
               legend.loc = "bottomleft",
               main = "Drawdown of Minimum Risk Portfolios")
```

Tables of annualized returns, risk measures and statistics:

```{r perf summary of minimum risk portfolios}
table.AnnualizedReturns(R = min_risk, scale = 52, Rf = 0.025/52, geometric = TRUE)

table.DownsideRisk(R = min_risk, scale = 52, Rf = 0.025/52, MAR = 0.07/52)

table.Stats(R = min_risk)
```

### 7.5 Summary

The equal-weight portfolio had the highest annualized return and standard deviation. Focusing on the minimum risk portfolios, the minimum MAD portfolio had the worst performance as it had the lowest returns with relatively high standard deviation and maximum drawdown.

## 8 Optimal Portfolio {.tabset .tabset-pills}

In this section, I select random portfolios that have mean or median return above the equal-weight portfolio mean or median return in the optimization period and find the portfolio that has the minimum risk in that subset of random portfolios.

This means that 6 portfolios are created, namely the Mean-Variance, Mean-MAD, Mean-MeAD, Median-Variance, Median-MAD and Median-MeAD portfolios.

### 8.1 Subset Random Portfolios

First of all, I find the set of random portfolios that satisfy the return requirement.

Random portfolios with a mean return above the equal-weight portfolio return in each optimization period:

```{r find rand ports with mean return above ewp mean return}
mean_port <- foreach(i = opt_periods) %do% {
  tmp <- PerformanceAnalytics::Mean.arithmetic(x = rp_returns[i, ])
  
  ewp_mean <- mean(x = ewp_return[i, ])
  
  mean_target <- rand_port[which(tmp > ewp_mean),]
}
```

Random portfolios with a median return above the equal-weight portfolio return in each optimization period:

```{r find rand ports with median return above ewp median return}
median_port <- foreach(i = opt_periods) %do% {
  tmp <- apply(X = rp_returns[i, ], MARGIN = 2, FUN = median)
  
  ewp_median <- median(x = ewp_return[i, ])
  
  median_target <- rand_port[which(tmp > ewp_median),]
}
```

Find the weekly return of the subset of random portfolios in each optimization period:

```{r weekly return of subset portfolios}
# Find returns from rp_returns that satisfy the target mean return constraint
meanport_return <- foreach(i = opt_periods) %do% {
  tmp <- PerformanceAnalytics::Mean.arithmetic(x = rp_returns[i, ])
  
  ewp_mean <- PerformanceAnalytics::Mean.arithmetic(x = ewp_return[i, ])
  
  mean_target <- rp_returns[i, which(tmp > as.vector(ewp_mean))]
}

# Find returns from rp_returns that satisfy the target median return constraint
medianport_return <- foreach(i = opt_periods) %do% {
  tmp <- apply(X = rp_returns[i, ], MARGIN = 2, FUN = median)
  
  ewp_median <- median(x = ewp_return[i, ])
  
  median_target <- rp_returns[i, which(tmp > ewp_median)]
}
```

### 8.2 Minimize Risk with Mean Return Constraint {.tabset .tabset-pills}

The steps are similar to Section 7, except I will be using the subset of random portfolio that satisfied the mean return constraint.

#### 8.2.1 Minimize Variance

Find weights that minimizes variance/standard deviation in each optimization period:

```{r find weights for mean variance portfolio}
meanvar_weight <- foreach(i = 1:length(meanport_return), .combine = "rbind") %do% {
  tmp <- PerformanceAnalytics::StdDev(R = meanport_return[[i]])
  
  opt_weight <- mean_port[[i]][which.min(tmp), ]
}

rownames(meanvar_weight) <- paste("OP", 1:nrow(meanvar_weight), sep = "")

data.frame(meanvar_weight)
```

Calculate return based on the selected portfolio weights in the return period:

```{r weekly return of mean variance portfolio}
meanvar_returns <- foreach(i = ret_periods, j = 1:nrow(meanvar_weight), .combine = "rbind") %do% {
  tmp <- PerformanceAnalytics::Return.portfolio(R = return_data[i, ], 
                                                weights = meanvar_weight[j, ], 
                                                geometric = TRUE, 
                                                rebalance_on = "quarters")
}
```

#### 8.2.2 Minimize MAD

Find weights that minimizes MAD in each optimization period:

```{r find weights for mean mad portfolio}
meanmad_weight <- foreach(i = 1:length(meanport_return), .combine = "rbind") %do% {
  tmp <- apply(X = meanport_return[[i]], MARGIN = 2, FUN = function(x) {
    mean(abs(x - mean(x)))
    })
  
  opt_weight <- mean_port[[i]][which.min(tmp), ]
}

rownames(meanmad_weight) <- paste("OP", 1:nrow(meanmad_weight), sep = "")

data.frame(meanmad_weight)
```

Calculate return based on the selected portfolio weights in the return period:

```{r weekly return of mean mad portfolio}
meanmad_returns <- foreach(i = ret_periods, j = 1:nrow(meanmad_weight), .combine = "rbind") %do% {
  tmp <- PerformanceAnalytics::Return.portfolio(R = return_data[i, ], 
                                                weights = meanmad_weight[j, ], 
                                                geometric = TRUE, 
                                                rebalance_on = "quarters")
}
```

#### 8.2.3 Minimize MeAD

Find weights that minimizes MeAD in each optimization period:

```{r find weights for mean mead portfolio}
meanmead_weight <- foreach(i = 1:length(meanport_return), .combine = "rbind") %do% {
  tmp <- apply(X = meanport_return[[i]], MARGIN = 2, FUN = function(x) {
    median(abs(x - median(x)))
    })
  
  opt_weight <- mean_port[[i]][which.min(tmp), ]
}

rownames(meanmead_weight) <- paste("OP", 1:nrow(meanmead_weight), sep = "")

data.frame(meanmead_weight)
```

Calculate return based on the selected portfolio weights in the return period:

```{r weekly return of mean mead portfolio}
meanmead_returns <- foreach(i = ret_periods, j = 1:nrow(meanmead_weight), .combine = "rbind") %do% {
  tmp <- PerformanceAnalytics::Return.portfolio(R = return_data[i, ], 
                                                weights = meanmead_weight[j, ], 
                                                geometric = TRUE, 
                                                rebalance_on = "quarters")
}
```

### 8.3 Minimize Risk with Median Return Constraint {.tabset .tabset-pills}

The steps are similar to Section 7, except I will be using the subset of random portfolio that satisfied the median return constraint.

#### 8.2.1 Minimize Variance

Find weights that minimizes variance/standard deviation in each optimization period:

```{r find weights for median variance portfolio}
medvar_weight <- foreach(i = 1:length(medianport_return), .combine = "rbind") %do% {
  tmp <- PerformanceAnalytics::StdDev(R = medianport_return[[i]])
  
  opt_weight <- median_port[[i]][which.min(tmp), ]
}

rownames(medvar_weight) <- paste("OP", 1:nrow(medvar_weight), sep = "")

data.frame(medvar_weight)
```

Calculate return based on the selected portfolio weights in the return period:

```{r weekly return of median variance portfolio}
medvar_returns <- foreach(i = ret_periods, j = 1:nrow(medvar_weight), .combine = "rbind") %do% {
  tmp <- PerformanceAnalytics::Return.portfolio(R = return_data[i, ], 
                                                weights = medvar_weight[j, ], 
                                                geometric = TRUE, 
                                                rebalance_on = "quarters")
}
```

#### 8.2.2 Minimize MAD

Find weights that minimizes MAD in each optimization period:

```{r find weights for median mad portfolio}
medmad_weight <- foreach(i = 1:length(medianport_return), .combine = "rbind") %do% {
  tmp <- apply(X = medianport_return[[i]], MARGIN = 2, FUN = function(x) {
    mean(abs(x - mean(x)))
    })
  
  opt_weight <- median_port[[i]][which.min(tmp), ]
}

rownames(medmad_weight) <- paste("OP", 1:nrow(medmad_weight), sep = "")

data.frame(medmad_weight)
```

Calculate return based on the selected portfolio weights in the return period:

```{r weekly return of median mad portfolio}
medmad_returns <- foreach(i = ret_periods, j = 1:nrow(medmad_weight), .combine = "rbind") %do% {
  tmp <- PerformanceAnalytics::Return.portfolio(R = return_data[i, ], 
                                                weights = medmad_weight[j, ], 
                                                geometric = TRUE, 
                                                rebalance_on = "quarters")
}
```

#### 8.2.3 Minimize MeAD

Find weights that minimizes MeAD in each optimization period:

```{r find weights for median mead portfolio}
medmead_weight <- foreach(i = 1:length(medianport_return), .combine = "rbind") %do% {
  tmp <- apply(X = medianport_return[[i]], MARGIN = 2, FUN = function(x) {
    median(abs(x - median(x)))
    })
  
  opt_weight <- median_port[[i]][which.min(tmp), ]
}

rownames(medmead_weight) <- paste("OP", 1:nrow(medmead_weight), sep = "")

data.frame(medmead_weight)
```

Calculate return based on the selected portfolio weights in the return period:

```{r weekly return of median mead portfolio}
medmead_returns <- foreach(i = ret_periods, j = 1:nrow(medmead_weight), .combine = "rbind") %do% {
  tmp <- PerformanceAnalytics::Return.portfolio(R = return_data[i, ], 
                                                weights = medmead_weight[j, ], 
                                                geometric = TRUE, 
                                                rebalance_on = "quarters")
}
```

### 8.4 Comparison of Optimal Portfolios

Plot weights of optimal portfolios:

```{r plot weights of optimal portfolios}
optport_weights <- list(Mean_Variance = meanvar_weight, Mean_MAD = meanmad_weight, Mean_MeAD = meanmead_weight,
                        Median_Variance = medvar_weight, Median_MAD = medmad_weight, Median_MeAD = medmead_weight)

for(i in 1:6) {
  chart.StackedBar(w = optport_weights[[i]], colorset = RColorBrewer::brewer.pal(n = 10, "Spectral"),
                 main = paste("Weights of", gsub(pattern = "_", replacement = " ", names(optport_weights)[i]), "Portfolio", sep = " "), 
                 ylab = "Weight")
}
```

Plot cumulative return of optimal portfolios against equal-weight portfolio return:

```{r plot returns of optimal portfolios}
opt_port <- cbind(meanvar_returns, meanmad_returns, meanmead_returns, medvar_returns, medmad_returns, medmead_returns, ewp_return["2016/"]) %>%
  `colnames<-`(c(names(optport_weights), "Equal Weight"))

chart.CumReturns(R = opt_port, geometric = TRUE, 
                 main = "Cumulative Return of Optimal Portfolios", 
                 plot.engine = "plotly")

chart.Drawdown(R = opt_port, geometric = TRUE, 
               main = "Drawdown of Optimal Portfolios", 
               plot.engine = "plotly")
```

Tables of annualized returns, risk measures and statistics:

```{r perf summary of optimal portfolios}
table.AnnualizedReturns(R = opt_port, scale = 52, Rf = 0.025/52, geometric = TRUE)

table.DownsideRisk(R = opt_port, scale = 52, Rf = 0.025/52, MAR = 0.07/52)

table.Stats(R = opt_port)
```

### 8.5 Summary

Looking at the annualized performance, the portfolios optimized using median returns seemed to performed worse than the portfolios optimized using mean returns. The only exception would be the Median-MeAD portfolio with comparable annualized return with the Mean-Variance and Mean-MeAD portfolios, although it had slightly higher annualized standard deviation. Annualized Sharpe Ratio was highest for the Mean-Variance portfolio, followed by the Mean-MeAD and the Median-MeAD portfolio. The Median-Variance portfolio was the worst performing, with low annualized return but relatively high annualized standard deviation.

Looking at the table of downside risk measures, the median portfolios generally had higher maximum drawdowns and historical expected shortfall than the mean portfolios.

The median portfolios generally did not out-performed the mean portfolios based on the sample of random hypothetical portfolios generated for this project.

## 9 Conclusion

The results of this project seemed to suggest that when the median return is maximized, a riskier portfolio is chosen as compared to when maximizing the mean return. There is more to study about the effect of median returns in portfolio optimization.

I would like to stress that the results are not generalizable as there were only 10 stocks chosen for this project and the random portfolios generated were just a small subset of an astronomical number of possible permutations. Furthermore, it should not be taken as evidence against the use of the median measure in portfolio optimization. For example, this [paper](https://www.dse.univr.it/documenti/Seminario/documenti/documenti719230.pdf) was able to find that median models provided benefits of portfolio diversification and returns.

## References

Frost, J. Mean Absolute Deviation: Definition, Finding & Formula. Statistics By Jim. Retrieved 28 July 2022, from https://statisticsbyjim.com/basics/mean-absolute-deviation/

Wikipedia. (2022). Average absolute deviation. Retrieved 29 July 2022, from https://en.wikipedia.org/wiki/Average_absolute_deviation

Wikipedia. (2022). Median absolute deviation. Retrieved 28 July 2022, from https://en.wikipedia.org/wiki/Median_absolute_deviation
