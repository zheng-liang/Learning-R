---
title: 'Calculating Returns: The Mean and The Median'
author: "Tan Zheng Liang"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: show 
    highlight: tango
    theme: flatly
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.align="center", message = FALSE, warning = FALSE)
knitr::knit_hooks$set(purl = knitr::hook_purl)
```

## 1 Introduction

In this project, my intention is to find out if using median returns in portfolio optimization could lead to better portfolio performance compared to mean returns. The use of mean returns might not accurately describe expected returns due to the non-normal distribution of financial returns. The mean is also known to be affected by outliers, whereas the median tend to be a more robust measure of central tendency. 

(To be completed last)

## 2 Packages Required

```{r load packages, message=FALSE, warning=FALSE}
library(PortfolioAnalytics) # For portfolio optimization and analysis
library(ROI) # For ROI solver in portfolio optimization
library(ROI.plugin.glpk) # Part of the ROI solver for linear optimization
library(ROI.plugin.quadprog) #Part of the ROI solver for quadratic optimization
library(tidyquant) # For quantmod and PerformanceAnalytics functions
library(tidyverse) # For dplyr and ggplot2 functions (data manipulation and plotting)
```

## 3 Retrieve Stock Prices and Calculate Returns {.tabset .tabset-pills}

I would sample 25 stocks randomly from the S&P500 Index and retrieve their daily adjusted closing prices from Yahoo Finance, starting January 2015 to June 2022. The daily stock returns are calculated using the discrete/simple method as it is used in calculating portfolio returns.

### 3.1 Index Components

The S&P500 Index components can be obtained using **`tidyquant::tq_index()`**.

```{r retrieve S&P500 index components}
# Only need columns 1 and 2, which are the tickers and name of company

sp500 <- tidyquant::tq_index(x = "SP500")[,1:2]

sp500

tickers <- sp500$symbol
```

### 3.2 Stock Prices of Components

The daily adjusted closing prices of the tickers from Yahoo Finance can be retrieved using **`quantmod::getSymbols()`**. From my previous project ([Random Selection, Expertise and Index Investing](https://tinyurl.com/2p8csyhj)), the tickers `BRK.B` and `BF.B` are different from those used by Yahoo Finance. I corrected them before obtaining the stock prices.

```{r retrieve price data}
# Correct the tickers for BRK.B and BF.B
tickers <- replace(x = tickers, list = tickers %in% c("BRK.B", "BF.B"), values = c("BRK-B", "BF-B"))

startdate <- as.Date("2015-01-01")
enddate <- as.Date("2022-07-01")

prices <- NULL

# Loop to get adjusted closing prices for all stocks
for (t in tickers) {   # Use for loop to get prices of all tickers
   
   tmp <- NULL
  
   tmp <- try(   # Use try function to skip loop and return error message when price cannot be retrieved
       expr = {Ad(quantmod::getSymbols(Symbols = t, src = "yahoo", auto.assign = FALSE, 
                                       from = startdate, to = enddate, periodicity = "daily"))},
       silent = TRUE
   )
   
   if(inherits(tmp, "try-error")) {cat("ERROR:", t, sep = " "); next}
   
   names(tmp) <- t
   
   prices <- cbind(prices, tmp)
}

# Check dimension of object, start and end date of data collected
dim(prices); start(prices); end(prices)
```

I only want stocks that have data for the period January 2015 to June 2022, and those that have missing values during this period would not be considered.

```{r remove stocks with missing values}
# Check which stocks have NA over the specified period
data.frame(rbind(which(colSums(is.na(prices)) > 0)), row.names = "Number of NAs")

# Keep only stocks that do not have NAs over the specified period
prices <- prices[, which(colSums(is.na(prices)) == 0)]

dim(prices) # Left with 482 stocks
```

### 3.3 Stock Returns for Portfolio

I would first sample the 25 stocks for the portfolio from `prices`, and this process is replicable using the **`set.seed()`**, unless changes have been made to the S&P500 Index components.

```{r sample 25 stocks from prices}
set.seed(42564)

samp_stocks <- prices[, sample(x = ncol(prices), size = 25, replace = FALSE)]

# Stocks sampled into portfolio
sp500[which(sp500$symbol %in% names(samp_stocks)),]
```

Discrete returns can be calculated using **`PerformanceAnalytics::Return.calculate()`**.

```{r calculate discrete returns}
stock_returns <- na.omit(PerformanceAnalytics::Return.calculate(prices = samp_stocks, method = "discrete"))

dim(stock_returns); data.frame(head(stock_returns))
```

## 4 Portfolios Optimized Using Mean Returns

The mean returns are used in this section to optimize the portfolio, using the variance (or standard deviation) and expected tail loss (or expected shortfall) as risk measures.

### 4.1 Maximizing Mean Returns

I created an initial portfolio specification using **`PortfolioAnalytics::portfolio.spec()`** with mean returns as an objective. The initial portfolio specification can be used throughout this project, with some adjustments to the objectives, depending on the return and risk measures.

```{r create initial portfolio specification}
init_spec <- PortfolioAnalytics::portfolio.spec(assets = names(stock_returns))

# Sum of weights constrained to 1, can also specify as type = "full investment"
init_spec <- PortfolioAnalytics::add.constraint(portfolio = init_spec, 
                                                type = "weight_sum", 
                                                min_sum = 1, max_sum = 1)

# Weight constraint on each stock, max is 10% of portfolio
init_spec <- PortfolioAnalytics::add.constraint(portfolio = init_spec, 
                                                type="box", 
                                                min = 0, max = 0.1)
```

Let's start off with creating a portfolio that maximizes mean returns only.

```{r portfolio specification to maximize mean returns}
max_meanreturns.spec <- PortfolioAnalytics::add.objective(portfolio = init_spec, 
                                                          type = "return",
                                                          name = "mean")

max_meanreturns.spec
```

For all portfolio optimizations in this project, a rolling-window optimization is used rather than a fixed-window as the relationships between stock returns may change over time. The portfolio would be re-optimized every 125 trading days (approximately half-yearly) using the previous 252 trading days of data (about one year) and rebalanced every quarter.

```{r optimize maximum mean return portfolio}
max_MeanReturn <- PortfolioAnalytics::optimize.portfolio.rebalancing(R = stock_returns, 
                                                                     portfolio = max_meanreturns.spec, 
                                                                     optimize_method = "ROI", rebalance_on = "quarter", 
                                                                     training_period = 252, rolling_window = 125)

max_MeanReturn
```
























